// HOWTO:
// Call setupRecognizer() first.
// Then, call let className = recognize([ input.acceleration(Dimension.X), input.acceleration(Dimension.Y), input.acceleration(Dimension.Z) ]);
// 'NONE' will be returned if nothing is detected.
// An example is at the end of this file.

// IMPORTANT: All number in microbit are integers.
function DTWDistanceFunction(dim: number, a: number[], astart: number, b: number[]) {
    let s = 0;
    for (let i = 0; i < dim; i++) {
        s += (a[i + astart] - b[i]) * (a[i + astart] - b[i]);
    }
    return Math.sqrt(s);
}
class DTWInfo {
    public dim: number;
    public prototype: number[];
    public s: number[];
    public d: number[];
    public prototypeSize: number;
    public t: number;
    public bestMatchEndsAtTDistance: number;
    // The distance of the best match that ends at t.
    public variance: number;
    // The variance computed.
    public bestMatchEndsAtTStart: number;
    // The start of the best match that ends at t.
    constructor(dim: number, prototype: number[], prototypeSize: number, variance: number) {
        this.dim = dim;
        this.prototypeSize = prototypeSize;
        this.prototype = prototype;
        this.d = %%ARRAY_INITIALIZATION%%;
        this.s = %%ARRAY_INITIALIZATION%%;
        this.t = 0;
        this.variance = variance;
        for (let i = 0; i <= prototypeSize; i++) {
            this.d[i] = 500000000;
            this.s[i] = 0;
        }
        this.d[0] = 0;
    }
    public feed(sample: number[]) {
        let d = this.d;
        let s = this.s;
        this.t += 1;
        d[0] = 0;
        s[0] = this.t;
        let dp = d[0];
        let sp = s[0];
        for (let i = 1; i <= this.prototypeSize; i++) {
            let dist = DTWDistanceFunction(this.dim, this.prototype, (i - 1) * this.dim, sample);
            let d_i_minus_1 = d[i - 1];
            let s_i_minus_1 = s[i - 1];
            let d_i_p = d[i];
            let s_i_p = s[i];
            let d_i_p_minus_1 = dp;
            let s_i_p_minus_1 = sp;
            dp = d[i];
            sp = s[i];
            if (d_i_minus_1 <= d_i_p && d_i_minus_1 <= d_i_p_minus_1) {
                d[i] = dist + d_i_minus_1;
                s[i] = s_i_minus_1;
            } else if (d_i_p <= d_i_minus_1 && d_i_p <= d_i_p_minus_1) {
                d[i] = dist + d_i_p;
                s[i] = s_i_p;
            } else {
                d[i] = dist + d_i_p_minus_1;
                s[i] = s_i_p_minus_1;
            }
        }
        this.bestMatchEndsAtTDistance = d[this.prototypeSize] / this.variance;
        this.bestMatchEndsAtTStart = s[this.prototypeSize];
    }
}

%%GLOBAL%%

function setupRecognizer() {
    let threshold = 1794; // confidenceThreshold = 0.2
%%SETUP%%
}

function recognize(sample: number[]): string {
%%MATCH%%
    let minClass = 'NONE';
    let minClassScore = 5000000;
%%MATCH_COMPARISON%%
    return minClass;
}

// Example application code:
setupRecognizer();
basic.forever(() => {
    // Recognize the gesture.
    let className = recognize([input.acceleration(Dimension.X), input.acceleration(Dimension.Y), input.acceleration(Dimension.Z)]);
    // Send the result over serial.
    serial.writeLine(className);
}
