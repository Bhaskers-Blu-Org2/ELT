/*
 * Sample DTW Model on accelerometer and gyroscope with generated recognizer code.
 * 
 * There are two modes for this code:
 *   - Data Collection Mode: change RUN_MODE to 0.
 *   - Running Mode: change RUN_MODE to 1, and paste in the recognizer code generated by the integrated app.
 *   
 * This file WILL produce non-uniform samples as there are glitches in the SD card write.
 * It mark each sample at its own timestamp using millis().
 * We should create a script that process non-uniform samples to uniform samples, or
 * fix this in the data loader code.
 * 
 * Based on Saleema's 1 class DTW, which is:
 * Based on Donghao's SPRING.ts code which implements the algorithm in
 * [1] Sakurai, Y., Faloutsos, C., & Yamamuro, M. (2007, April). 
 * Stream monitoring under the time warping distance. 
 * In 2007 IEEE 23rd International Conference on Data Engineering (pp. 1046-1055). IEEE.
 * 
 * The circuit:
 * button is wired to GND and digital pin 5
 * 
 * SD card attached to SPI bus as follows (integrated in Feather board):
 ** MOSI - pin 11
 ** MISO - pin 12
 ** CLK - pin 13
 ** CS - pin 4

 * created 9/16/2016
 * by Donghao Ren
 
 */

// Some of this configuration and setup is based on the dataCollection code. We might not need all of these.....
#include <string.h>
#include <stdlib.h>
#include <SPI.h>
#include <SD.h>
#include <Wire.h> 
#include <RTClib.h>
#include <Adafruit_LSM303_U.h>
#include <Adafruit_L3GD20_U.h>
#include <Adafruit_BMP085_U.h>
#include <Adafruit_Sensor.h>

const int RUN_MODE = 1; // 0 for data collection, 1 for prediction.

// Constants
const float frequency = 50; // Unit: Hz
const String boardNum = "COM2"; // Serial number
const int buttonPin = 9;

const int chipSelect = 4;
const int rate = (int)(1000.0/frequency);

const int ledPin = 13; 

// Sensor configuration variables
Adafruit_LSM303_Accel_Unified accel = Adafruit_LSM303_Accel_Unified(54321);
Adafruit_LSM303_Mag_Unified mag = Adafruit_LSM303_Mag_Unified(12345);
Adafruit_L3GD20_Unified gyro = Adafruit_L3GD20_Unified(20);
Adafruit_BMP085_Unified bmp = Adafruit_BMP085_Unified(10085);
RTC_DS3231 rtc;

float acc_x, acc_y, acc_z;
float mag_x, mag_y, mag_z;
float gyro_x, gyro_y, gyro_z;
float prs;
float temp;
float span;
uint32_t buttonClick;
int old = 1;

// global variables for timing
uint32_t nextSampleTimeInMs = 0;
uint32_t startTimeInS = 0;

// This function waits until the next valid sample time. If the function is called before the next sample time
// it spins until the sample time arrives. If the function is called after the next sample time, it waits until the next valid sample time. 
void wait()
{
  while(true) {
    uint32_t t = millis();
    if(t >= nextSampleTimeInMs) {
      nextSampleTimeInMs = t + rate;
      break;
    }
  }
}

File dataFile;

void setup() {
  setupRecognizer(0.2);
  /******** Button Setup ********************/ 
  // Set up pin mode for external modules
  pinMode(buttonPin, INPUT_PULLUP);
  pinMode(ledPin, OUTPUT);
  digitalWrite(ledPin, HIGH);
  Serial.begin(115200);
  
  // Confirm that all of the sensors started
  gyro.enableAutoRange(true);
  mag.enableAutoRange(true);
  accel.begin();  // Accelerometer setup 
  mag.begin();    // Magnetometer setup
  gyro.begin();   // Gyroscope setup
  bmp.begin();    // Pressure setup
  rtc.begin();    // RTC setup

  if(RUN_MODE == 0) {
    SD.begin(chipSelect);
    for(int i = 0; ; i++) {
      String filename = "log" + String(i) + ".tsv";
      if(SD.exists(filename)) continue;
      else {
        dataFile = SD.open(filename, FILE_WRITE);
        break;
      }
    }
  }

  // If the clock lost power (e.g, its coin cell was removed), set its time to the compile time of this sketch
  if(rtc.lostPower()) {
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  }

  if(RUN_MODE == 0) {
    dataFile.flush();
  }
}


int sampleIndex = 0;

char floatToStringBuf[20];
const char* floatToString(float f) {
  int intValue = f * 10000;
  if(intValue >= 0) {
    sprintf(floatToStringBuf, "%d.%04d", intValue / 10000, intValue % 10000);
  } else {
    sprintf(floatToStringBuf, "-%d.%04d", (-intValue) / 10000, (-intValue) % 10000);
  }
  return floatToStringBuf;
}

void loop() {
    wait();

    sampleIndex++;

    digitalWrite(ledPin, (sampleIndex / 10) % 2 == 0 ? LOW : HIGH);

    /****************** Accelerometer & Compass Reading ******************/
    // Get a new sensor event
    sensors_event_t event; 
    if(accel.getEvent(&event)) {
      acc_x = event.acceleration.x;
      acc_y = event.acceleration.y;
      acc_z = event.acceleration.z;
    }
    
    // Get a new sensor event
    sensors_event_t event2;  
    if(gyro.getEvent(&event2)) {
      gyro_x = event2.gyro.x;
      gyro_y = event2.gyro.y;
      gyro_z = event2.gyro.z;
    }
    
    if(RUN_MODE == 0) {
      char buffer[200];
      sprintf(buffer, "%d\t", millis());
      strcat(buffer, floatToString(acc_x)); strcat(buffer, "\t");
      strcat(buffer, floatToString(acc_y)); strcat(buffer, "\t");
      strcat(buffer, floatToString(acc_z)); strcat(buffer, "\t");
      strcat(buffer, "\t\t\t"); // skip the mag fields.
      strcat(buffer, floatToString(gyro_x)); strcat(buffer, "\t");
      strcat(buffer, floatToString(gyro_y)); strcat(buffer, "\t");
      strcat(buffer, floatToString(gyro_z)); strcat(buffer, "\n");
      dataFile.print(buffer);
  
      if(sampleIndex % 100 == 0) {
        dataFile.flush();
      }
    }
    if(RUN_MODE == 1) {
      float sensor_array[] = { acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z };
      String result = recognize(sensor_array);
      if(result != "NONE") {
        Serial.println(result);
      }
    }
}
